---
title: "Nested EnVar with cross covariance"
format:
  html:
    code-fold: true
    code-tools: true
jupyter: python3
editor:
  render-on-save: true
---

```{python}
import numpy as np
import numpy.linalg as la
import matplotlib.pyplot as plt
from pathlib import Path
```

# Formulation
```{=tex}
\begin{align*}
J(\mathbf{w})&=
\frac{1}{2}
\begin{bmatrix}
\begin{pmatrix}
\mathbf{0}\\\mathbf{d}^\mathrm{v}
\end{pmatrix}
-
\begin{pmatrix}
\mathbf{X}^\mathrm{b}\\
\mathbf{Z}^\mathrm{b}
\end{pmatrix}
\mathbf{w}
\end{bmatrix}^\mathrm{T}
\begin{pmatrix}
\mathbf{P}^\mathrm{b} & \mathbf{P}^\mathrm{bv} \\
\mathbf{P}^\mathrm{vb} & \mathbf{P}^\mathrm{v}
\end{pmatrix}^{-1}
\begin{bmatrix}
\begin{pmatrix}
\mathbf{0}\\\mathbf{d}^\mathrm{v}
\end{pmatrix}
-
\begin{pmatrix}
\mathbf{X}^\mathrm{b}\\
\mathbf{Z}^\mathrm{b}
\end{pmatrix}
\mathbf{w}
\end{bmatrix}
+\frac{1}{2}(\mathbf{d}^\mathrm{o}-\mathbf{Y}^\mathrm{b}\mathbf{w})^\mathrm{T}\mathbf{R}^{-1}(\mathbf{d}^\mathrm{o}-\mathbf{Y}^\mathrm{b}\mathbf{w})\\
&=\frac{1}{2}
\begin{bmatrix}
\begin{pmatrix}
\mathbf{0}\\\mathbf{d}^\mathrm{v}
\end{pmatrix}
-
\begin{pmatrix}
\mathbf{X}^\mathrm{b}\\
\mathbf{Z}^\mathrm{b}
\end{pmatrix}
\mathbf{w}
\end{bmatrix}^\mathrm{T}
\begin{bmatrix}
\tilde{\mathbf{d}}^\mathrm{v}
-
\tilde{\mathbf{X}}^\mathrm{b}
\mathbf{w}
\end{bmatrix}
+\frac{1}{2}(\mathbf{d}^\mathrm{o}-\mathbf{Y}^\mathrm{b}\mathbf{w})^\mathrm{T}\mathbf{R}^{-1}(\mathbf{d}^\mathrm{o}-\mathbf{Y}^\mathrm{b}\mathbf{w})
\end{align*}
```

```{=tex}
\begin{align*}
\nabla_\mathbf{w}J&=
\left[
\begin{pmatrix}
\mathbf{X}^\mathrm{b}\\
\mathbf{Z}^\mathrm{b}
\end{pmatrix}^\mathrm{T}
\begin{pmatrix}
    \mathbf{P}^\mathrm{b} & \mathbf{P}^\mathrm{bv} \\
    \mathbf{P}^\mathrm{vb} & \mathbf{P}^\mathrm{v}
\end{pmatrix}^{-1}
\begin{pmatrix}
    \mathbf{X}^\mathrm{b}\\
    \mathbf{Z}^\mathrm{b}
\end{pmatrix}
+(\mathbf{Y}^\mathrm{b})^\mathrm{T}\mathbf{R}^{-1}\mathbf{Y}^\mathrm{b}
\right]\mathbf{w}
-
\begin{pmatrix}
\mathbf{X}^\mathrm{b}\\
\mathbf{Z}^\mathrm{b}
\end{pmatrix}^\mathrm{T}
\begin{pmatrix}
    \mathbf{P}^\mathrm{b} & \mathbf{P}^\mathrm{bv} \\
    \mathbf{P}^\mathrm{vb} & \mathbf{P}^\mathrm{v}
    \end{pmatrix}^{-1}
    \begin{pmatrix}
    \mathbf{0}\\
    \mathbf{d}^\mathrm{v}
\end{pmatrix}
-(\mathbf{Y}^\mathrm{b})^\mathrm{T}\mathbf{R}^{-1}\mathbf{d}^\mathrm{o}\\
&=\underbrace{\left[
\begin{pmatrix}
\mathbf{X}^\mathrm{b}\\
\mathbf{Z}^\mathrm{b}
\end{pmatrix}^\mathrm{T}
\tilde{\mathbf{X}}^\mathrm{b}
+(\mathbf{Y}^\mathrm{b})^\mathrm{T}\mathbf{R}^{-1}\mathbf{Y}^\mathrm{b}
\right]}_{\nabla^2_\mathbf{w}J}
\mathbf{w}
-
\begin{pmatrix}
\mathbf{X}^\mathrm{b}\\
\mathbf{Z}^\mathrm{b}
\end{pmatrix}^\mathrm{T}
\tilde{\mathbf{d}}^\mathrm{v}
-(\mathbf{Y}^\mathrm{b})^\mathrm{T}\mathbf{R}^{-1}\mathbf{d}^\mathrm{o}
=0
\end{align*}
```

$$
\begin{pmatrix}
    \mathbf{P}^\mathrm{b} & \mathbf{P}^\mathrm{bv} \\
    \mathbf{P}^\mathrm{vb} & \mathbf{P}^\mathrm{v}
\end{pmatrix}\tilde{\mathbf{X}}^\mathrm{b}
=
\begin{pmatrix}
    \mathbf{X}^\mathrm{b}\\
    \mathbf{Z}^\mathrm{b}
\end{pmatrix}
$$

$$
\begin{pmatrix}
    \mathbf{P}^\mathrm{b} & \mathbf{P}^\mathrm{bv} \\
    \mathbf{P}^\mathrm{vb} & \mathbf{P}^\mathrm{v}
\end{pmatrix}\tilde{\mathbf{d}}^\mathrm{v}
=
\begin{pmatrix}
\mathbf{0}\\\mathbf{d}^\mathrm{v}
\end{pmatrix}
$$

$$
\begin{pmatrix}
\mathbf{P}^\mathrm{b} & \mathbf{P}^\mathrm{bv} \\
\mathbf{P}^\mathrm{vb} & \mathbf{P}^\mathrm{v}
\end{pmatrix}
= \frac{1}{K-1}
\begin{pmatrix}
\mathbf{X}^\mathrm{b} \\
\mathbf{Z}^\mathrm{v}
\end{pmatrix}
\begin{bmatrix}
(\mathbf{X}^\mathrm{b})^\mathrm{T} &
(\mathbf{Z}^\mathrm{v})^\mathrm{T}
\end{bmatrix}
$$

```{python}
def cost(w,*args):
    Xb, Yb, Zb, do, dv, Xb_, dv_ = args
    tmp1 = np.hstack((np.zeros(Xb.shape[0]),dv-Zb@w))
    tmp2 = dv_ - Xb_ @ w
    tmp3 = do - Yb @ w # R=I
    return 0.5*(np.dot(tmp1,tmp2)+np.dot(tmp3,tmp3))

def solve(*args):
    Xb, Yb, Zb, do, dv, Xb_, dv_ = args
    hess = np.hstack((Xb.T,Zb.T)) @ Xb_ + Yb.T @ Yb # R=I
    rhs = np.hstack((Xb.T,Zb.T)) @ dv_ + Yb.T @ do
    w = la.solve(hess,rhs)

    # update ensemble prtb
    lam, c = la.eigh(hess)
    ndof = np.sum(lam>1.0e-10)
    if ndof < lam.size:
        D = np.diag(np.hstack((np.zeros(lam.size-ndof),1.0/np.sqrt(lam[lam.size-ndof:]))))
    else:
        D = np.diag(1.0/np.sqrt(lam))
    
    trans = c @ D @ c.T
    return w, trans
```

# Example

```{python}
model = "l05nestm"
datadir = Path(f'/Volumes/nakashita/Development/pydpac/work/{model}/var_vs_envar_shrink_dct_preGM_m80obs30')
#datadir = Path(f'/Volumes/FF520/nested_envar/data/{model}/var_vs_envar_shrink_dct_preGM_m80obs30')
ix_gm = np.loadtxt(datadir/"ix_gm.txt")
ix_lam = np.loadtxt(datadir/"ix_lam.txt")
def loaddata(icycle,pt):
    Xb = np.load(datadir/f"data/{pt}/{model}_lam_spf_linear_{pt}_cycle{icycle}.npy")
    Xb *= np.sqrt(Xb.shape[1]-1)
    Zv = np.load(datadir/f"data/{pt}/{model}_lam_zvmat_linear_{pt}_cycle{icycle}.npy")
    Zb = np.load(datadir/f"data/{pt}/{model}_lam_zbmat_linear_{pt}_cycle{icycle}.npy")
    dv = np.load(datadir/f"data/{pt}/{model}_lam_dk_linear_{pt}_cycle{icycle}.npy")
    Yb = np.load(datadir/f"data/{pt}/{model}_lam_dh_linear_{pt}_cycle{icycle}.npy")
    do = np.load(datadir/f"data/{pt}/{model}_lam_d_linear_{pt}_cycle{icycle}.npy")
    # debug
    dx = np.load(datadir/f"data/{pt}/{model}_lam_dx_linear_{pt}_cycle{icycle}.npy")
    dx_conv = np.load(datadir/f"data/envar/{model}_lam_dx_linear_envar_cycle{icycle}.npy")
    Xb_conv = np.load(datadir/f"data/envar/{model}_lam_spf_linear_envar_cycle{icycle}.npy")
    Xb_conv *= np.sqrt(Xb.shape[1]-1)
    Yb_conv = np.load(datadir/f"data/envar/{model}_lam_dh_linear_envar_cycle{icycle}.npy")
    do_conv = np.load(datadir/f"data/envar/{model}_lam_d_linear_envar_cycle{icycle}.npy")

    return Xb, Zb, Zv, Yb, do, dv, dx, dx_conv, Xb_conv, Yb_conv, do_conv

icycle=50
pt="envar_nest"
Xb, Zb, Zv, Yb, do, dv, dx, dx_conv, Xb_conv, Yb_conv, do_conv = loaddata(icycle,pt)
print(Xb.shape)
print(Zv.shape)
print(Zb.shape)
print(dv.shape)
print(Yb.shape)
print(do.shape)
print(dx.shape)
```

```{python}
#| output: false

from analysis.obs import Obs
from analysis.envar import EnVAR
from analysis.envar_nest import EnVAR_nest
from analysis.minimize import Minimize
state_size = Xb.shape[0]
nmem = Xb.shape[1]
obs = Obs("linear",1.0) # dummy

envar = EnVAR(state_size,nmem,obs,model="l05nestm")
envar_nest = EnVAR_nest(state_size,nmem,obs,ix_gm,ix_lam,pt="envar_nest",ntrunc=12,\
    crosscov=False, model="l05nestm")
```

```{python}
#| fig-cap: ensemble perturbations
#| fig-subcap:
#|   - Xb
#|   - Zb, Zv, Yb
#| label: fig-ensprtb
#| layout: [[1,2],[1]]

fig, ax = plt.subplots()
mp0=ax.matshow(Xb)
fig.colorbar(mp0,ax=ax,shrink=0.6,pad=0.01)
ax.set_title('Xb')
plt.show()

fig2, axs = plt.subplots(nrows=3,constrained_layout=True)
axs[0].set_title('Zb')
mp1=axs[0].matshow(Zb)
axs[1].set_title('Zv')
mp2=axs[1].matshow(Zv)
axs[2].set_title('Yb')
mp3=axs[2].matshow(Yb)
for mp, ax in zip([mp1,mp2,mp3],axs):
    fig2.colorbar(mp,ax=ax,pad=0.01,shrink=0.6,orientation='horizontal')
plt.show()

```

```{python}
#| fig-cap: innovations
#| fig-subcap:
#|   - observation (d^o)
#|   - large-scale (d^v)
#| label: fig-innv
#| layout-ncol: 2

fig, ax = plt.subplots()
ax.plot(do,np.arange(do.size))
ax.set_xlabel('d^o')
ax.vlines([0],0,1,colors='gray',transform=ax.get_xaxis_transform())
plt.show()

fig, ax = plt.subplots()
ax.plot(dv,np.arange(dv.size))
ax.set_xlabel('d^v')
ax.vlines([0],0,1,colors='gray',transform=ax.get_xaxis_transform())
plt.show()

```

```{python}
#| fig-cap: ensemble error covariances
#| fig-subcap:
#|   - Pb
#|   - Pv
#|   - Pvb
#| label: fig-enserr-each

from matplotlib.colors import Normalize

Pb = np.dot(Xb,Xb.transpose())/(nmem-1)
Pbv = np.dot(Xb,Zv.transpose())/(nmem-1)
Pvb = np.dot(Zv,Xb.transpose())/(nmem-1)
Pv = np.dot(Zv,Zv.transpose())/(nmem-1)

vlim = max(
    np.max(Pb),-np.min(Pb),
    np.max(Pbv),-np.min(Pbv),
    np.max(Pvb),-np.min(Pvb),
    np.max(Pv),-np.min(Pv)
)

fig, ax = plt.subplots()
mp0 = ax.matshow(Pb,cmap='coolwarm',norm=Normalize(vmin=-vlim,vmax=vlim))
fig.colorbar(mp0,ax=ax,shrink=0.6,pad=0.01)
ax.set_aspect('equal')
plt.show()
fig, ax = plt.subplots()
mp3 = ax.matshow(Pv,cmap='coolwarm',norm=Normalize(vmin=-vlim,vmax=vlim))
fig.colorbar(mp3,ax=ax,shrink=0.6,pad=0.01)
ax.set_aspect('equal')
plt.show()
fig, ax = plt.subplots()
mp2 = ax.matshow(Pvb,cmap='coolwarm',norm=Normalize(vmin=-vlim,vmax=vlim))
fig.colorbar(mp2,ax=ax,shrink=0.6,pad=0.01,orientation='horizontal')
ax.set_aspect(5)
plt.show()

```

```{python}
#| fig-cap: composite ensemble error covariance
#| label: fig-enserr

Pc = np.vstack((np.hstack((Pb,Pbv)),np.hstack((Pvb,Pv))))

fig, ax = plt.subplots()
mp = ax.matshow(Pc,cmap='coolwarm',norm=Normalize(-vlim,vlim))
fig.colorbar(mp,ax=ax,pad=0.01,shrink=0.6)
plt.show()
```

0. solution without large-scale terms or without cross covariance ($\mathbf{P}^\mathrm{bv}=\mathbf{P}^\mathrm{vb}=0$)

```{python}
#| output: false
    # without large-scale terms
    #Xb_tmp = np.vstack(((nmem-1)*np.eye(Xb.shape[1]),np.zeros_like(Zb)))
    #dv_tmp = np.zeros(Xb.shape[0]+Zb.shape[0])
    #args_conv = (np.eye(Xb.shape[1]), Yb_conv, Zb, do_conv, dv, Xb_tmp, dv_tmp)
    #w_conv, trans_conv = solve(*args_conv)
    trans_conv, heinv = envar.precondition(Yb_conv)
    args_conv = (do_conv, trans_conv, Yb_conv, heinv)
    minimize = Minimize(nmem, envar.calc_j, jac=envar.calc_grad_j, hess=envar.calc_hess, args=args_conv)
    z_conv, _ = minimize(np.zeros(nmem))
    w_conv = trans_conv @ z_conv
    Xa_conv = np.sqrt(nmem-1)*Xb_conv@trans_conv
```
```{python}
    #Ji = cost(np.zeros_like(w_nc),*args)
    #Jf = cost(w_nc,*args)
    Ji = envar.calc_j(np.zeros_like(z_conv), *args_conv)
    Jf = envar.calc_j(z_conv, *args_conv)
    print(f"initial cost={Ji:.4e}")
    print(f"final cost={Jf:.4e}")

```

```{python}
#| output: false

    #Xb_ = np.vstack(((nmem-1)*np.eye(Xb.shape[1]),la.pinv(Pv)@Zb))
    #dv_ = np.hstack((np.zeros(Xb.shape[1]),la.pinv(Pv)@dv))
    #args = (np.eye(Xb.shape[1]), Yb, Zb, do, dv, Xb_, dv_)
    #w_nc, trans_nc = solve(*args)
    #Xa_nc = np.sqrt(nmem-1)*Xb@trans_nc

    Zvd = la.pinv(Zv)
    #qmat = Zvd @ Zb
    #dvtmp = Zvd @ dv
    schurinv = Zvd.T @ Zvd
    coef_a = 0.0
    args_prec = (Yb, Zb, schurinv, coef_a)
    trans_nc, heinv = envar_nest.precondition(*args_prec)
    #args = (do, trans_nc, Yb, dvtmp, qmat, heinv)
    args = (do, trans_nc, Yb, dv, Zb, schurinv, coef_a, heinv)
    minimize = Minimize(nmem, envar_nest.calc_j, jac=envar_nest.calc_grad_j, hess=envar_nest.calc_hess, args=args)
    z_nc, _ = minimize(np.zeros(nmem))
    w_nc = trans_nc @ z_nc
    Xa_nc = np.sqrt(nmem-1)*Xb@trans_nc
```
```{python}
    #Ji = cost(np.zeros_like(w_nc),*args)
    #Jf = cost(w_nc,*args)
    Ji = envar_nest.calc_j(np.zeros_like(z_nc), *args)
    Jf = envar_nest.calc_j(z_nc, *args)
    print(f"initial cost={Ji:.4e}")
    print(f"final cost={Jf:.4e}")
```

<!---
```{python}
#| fig-cap: solution without cross covariance
#| fig-subcap:
#|   - $\tilde{X}^b$
#|   - $\tilde{d}^b$
#| label: fig-nocross
#| layout: [[2,3],[1]]

#    fig, ax = plt.subplots()
#    mp=ax.matshow(Xb_)
#    fig.colorbar(mp,ax=ax,pad=0.01,shrink=0.6)
#    ax.set_aspect(0.5)
#    plt.show()

#    fig, ax = plt.subplots()
#    ax.plot(dv_,np.arange(dv_.size))
#    ax.set_xlabel(r'$\tilde{d}^v$')
#    ax.vlines([0],0,1,colors='gray',transform=ax.get_xaxis_transform())
#    plt.show()
```

--->

```{python}
#| fig-cap: solution without cross covariance or without large-scale term
#| fig-subcap:
#|   - $\mathbf{w}$
#|   - $\delta\mathbf{x}$
#|   - Xb, Xa
#|   - $[\nabla^2 J]^{-1/2}$
#| label: fig-nocross-cost
#| layout: [[1,2],[1]]
    
    cmap = plt.get_cmap('tab10')
    fig, ax = plt.subplots(figsize=[4,6])
    ax.plot(w_nc,np.arange(1,w_nc.size+1),label='no cross')
    ax.plot(w_conv,np.arange(1,w_nc.size+1),label='no V')
    xmin,xmax = ax.get_xlim()
    xlimref = max(-xmin,xmax)
    ax.set_xlim(-xlimref,xlimref)
    ax.legend()
    ax.set_ylabel('member')
    ax.set_xlabel('w')
    plt.show()

    fig, ax = plt.subplots(figsize=[8,6])
    dx_nc = Xb@w_nc
    dx_conv = Xb@w_conv
    ax.plot(dx_nc,label='no cross')
    ax.plot(dx_conv,label='no V')
    #ax.plot(dx_conv,ls='dashed')
    #ax.plot(dx,ls='dashed')
    ymin,ymax = ax.get_ylim()
    ylimref = max(-ymin,ymax)
    ax.set_ylim(-ylimref,ylimref)
    ax.legend()
    ax.set_xlabel('grid')
    ax.set_ylabel('dx')
    plt.show()

    fig, axs = plt.subplots(ncols=3,constrained_layout=True)
    vlim = max(
        np.max(Xb),-np.min(Xb),
        np.max(Xa_conv),-np.min(Xa_conv),
        np.max(Xa_nc),-np.min(Xa_nc)
    )
    mp0=axs[0].matshow(Xb,norm=Normalize(-vlim,vlim))
    #fig.colorbar(mp0,ax=axs[0],shrink=0.6,pad=0.01)
    axs[0].set_title('Xb')
    mp1=axs[1].matshow(Xa_conv,norm=Normalize(-vlim,vlim))
    #fig.colorbar(mp1,ax=axs[1],shrink=0.6,pad=0.01)
    axs[1].set_title('Xa (no V)')
    mp2=axs[2].matshow(Xa_nc,norm=Normalize(-vlim,vlim))
    fig.colorbar(mp2,ax=axs[2],shrink=0.6,pad=0.01)
    axs[2].set_title('Xa (no cross)')
    plt.show()

    fig, axs = plt.subplots(ncols=2,constrained_layout=True)
    mp0=axs[0].matshow(trans_nc)
    fig.colorbar(mp0,ax=axs[0],shrink=0.6,pad=0.01)
    axs[0].set_title('trans (no cross)')
    mp1=axs[1].matshow(trans_conv)
    fig.colorbar(mp1,ax=axs[1],shrink=0.6,pad=0.01)
    axs[1].set_title('trans (no V)')
    plt.show()

```

1. truncated pseudo-inverse (minimum-norm solution)
    $$
    \tilde{\mathbf{X}}^\mathrm{b}
    =
    \begin{pmatrix}
        \mathbf{P}^\mathrm{b} & \mathbf{P}^\mathrm{bv} \\
        \mathbf{P}^\mathrm{vb} & \mathbf{P}^\mathrm{v}
    \end{pmatrix}^\dagger
    \begin{pmatrix}
        \mathbf{X}^\mathrm{b}\\
        \mathbf{Z}^\mathrm{b}
    \end{pmatrix}
    =\left\{\begin{pmatrix}
    \mathbf{X}^\mathrm{b} \\
    \mathbf{Z}^\mathrm{v}
    \end{pmatrix}^\dagger\right\}^\mathrm{T}
    \begin{pmatrix}
    \mathbf{X}^\mathrm{b} \\
    \mathbf{Z}^\mathrm{v}
    \end{pmatrix}^\dagger
    \begin{pmatrix}
        \mathbf{X}^\mathrm{b}\\
        \mathbf{Z}^\mathrm{b}
    \end{pmatrix}
    $${#eq-psd-1}
    $$
    \tilde{\mathbf{d}}^\mathrm{v}
    =
    \begin{pmatrix}
        \mathbf{P}^\mathrm{b} & \mathbf{P}^\mathrm{bv} \\
        \mathbf{P}^\mathrm{vb} & \mathbf{P}^\mathrm{v}
    \end{pmatrix}^\dagger
    \begin{pmatrix}
    \mathbf{0}\\\mathbf{d}^\mathrm{v}
    \end{pmatrix}
    =
    \left\{\begin{pmatrix}
    \mathbf{X}^\mathrm{b} \\
    \mathbf{Z}^\mathrm{v}
    \end{pmatrix}^\dagger\right\}^\mathrm{T}
    \begin{pmatrix}
    \mathbf{X}^\mathrm{b} \\
    \mathbf{Z}^\mathrm{v}
    \end{pmatrix}^\dagger
    \begin{pmatrix}
    \mathbf{0}\\\mathbf{d}^\mathrm{v}
    \end{pmatrix}
    $${#eq-psd-2}

```{python}
#| output: false

    envar_nestc = EnVAR_nest(state_size,nmem,obs,ix_gm,ix_lam,pt="envar_nestc",ntrunc=12,\
    crosscov=True,ortho=False,ridge=True,mu=0.0,model="l05nestm")

    dxc1 = np.vstack((Xb,Zv))
    dxc2 = np.vstack((Xb,Zb))
    u, s, vt = la.svd(dxc1)
    ndof = int(np.sum(s>1.0e-10))
    vsqrtinv = vt[:ndof,:].transpose() @ np.diag(1.0/s[:ndof]) @ u[:,:ndof].transpose()
    lam = s*s
    lamsum = np.sum(lam)
    
    contriblist = [100,95,90,85,80]
    ndoflist = []
    argslist = []
    zlist = []
    wlist = []
    Xalist = []
    translist = []
    for contrib in contriblist:
        if contrib==100:
            ndof = int(np.sum(s>1.0e-10))
        else:
            ndof = 1
            while ndof < s.size:
                c = np.sum(lam[:ndof])/lamsum
                if c*100>contrib: break
                ndof+=1
        ndoflist.append(ndof)
        vsqrtinvtmp = vt[:ndof,:].transpose() @ np.diag(1.0/s[:ndof]) @ u[:,:ndof].transpose()
        qmat = vsqrtinvtmp @ dxc2
        dvtmp = vsqrtinvtmp @ np.hstack((np.zeros(Xb.shape[0]),dv))
        args_prec = (Yb,qmat)
        trans, heinv = envar_nestc.precondition(*args_prec)
        args = (do, trans, Yb, dvtmp, qmat, heinv)
        argslist.append(args)
        minimize = Minimize(nmem, envar_nestc.calc_j, jac=envar_nestc.calc_grad_j, hess=envar_nestc.calc_hess, args=args)
        z, _ = minimize(np.zeros(nmem))
        w = trans @ z
        Xa = np.sqrt(nmem-1)*Xb@trans
        zlist.append(z)
        wlist.append(w)
        Xalist.append(Xa)
        translist.append(trans)

    Pcpinv = la.pinv(Pc,hermitian=True)
    Xb_ = Pcpinv @ np.vstack((Xb,Zb))
    dv_ = Pcpinv @ np.hstack((np.zeros(Xb.shape[0]),dv))
    #
    #args = (Xb, Yb, Zb, do, dv, Xb_, dv_)
    #w, trans = solve(*args)
    #Xa = np.sqrt(nmem-1)*Xb@trans
```
```{python}
    Jlist = []
    for contrib, z, args in zip(contriblist,zlist,argslist):
        Ji = envar_nestc.calc_j(np.zeros(nmem),*args)
        Jf = envar_nestc.calc_j(z,*args)
        #Ji = cost(np.zeros_like(w),*args)
        #Jf = cost(w,*args)
        print(f"contrib={contrib}% ndof={ndoflist[contriblist.index(contrib)]}")
        print(f"contrib={contrib}% initial cost={Ji:.4e}")
        print(f"contrib={contrib}% final cost={Jf:.4e}")
        Jlist.append([Ji,Jf])

```

```{python}
#| fig-cap: Sensitivity of $J$ to truncated modes
#| label: fig-minnorm-cost-c

    Jarray = np.array(Jlist)
    fig, ax = plt.subplots()
    #ax.plot(mulist,Jarray[:,0],marker='o',ms=10,lw=0.0,label='initial')
    ax.plot(contriblist,Jarray[:,1],marker='s',ms=10,lw=0.0,label='final')
    ax.legend()
    ax.set_yscale('log')
    ax.set_ylabel('J')
    ax.set_xlabel('contribution (%)')
    plt.show()

```

<!---
```{python}
#| fig-cap: minimum-norm solution
#| fig-subcap:
#|   - $\tilde{X}^b$
#|   - $\tilde{d}^b$
#| label: fig-minnorm
#| layout: [[2,3],[1]]

    fig, ax = plt.subplots()
    mp=ax.matshow(Xb_)
    fig.colorbar(mp,ax=ax,pad=0.01,shrink=0.6)
    ax.set_aspect(0.5)
    plt.show()

    fig, ax = plt.subplots()
    ax.plot(dv_,np.arange(dv_.size))
    ax.set_xlabel(r'$\tilde{d}^v$')
    ax.vlines([0],0,1,colors='gray',transform=ax.get_xaxis_transform())
    plt.show()

```
--->

```{python}
#| fig-cap: minimum-norm solution for $J$
#| fig-subcap:
#|   - $\mathbf{w}$
#|   - $\delta\mathbf{x}$
#|   - Xb, Xa
#|   - $[\nabla^2 J]^{-1/2}$
#| label: fig-minnorm-cost
#| layout: [[1,2],[1]]
    
    fig, ax = plt.subplots(figsize=[4,6])
    ax.plot(w_nc,np.arange(1,w_nc.size+1),ls='dashed',label='no cross')
    ax.plot(w_conv,np.arange(1,w_conv.size+1),ls='dotted',label='no V')
    for c, w in zip(contriblist,wlist):
        ax.plot(w,np.arange(1,w.size+1),label=f'cross,{c}%')
    xmin,xmax = ax.get_xlim()
    xlim = max(-xmin,xmax)
    ax.set_xlim(-xlimref,xlimref)
    ax.legend()
    ax.set_ylabel('member')
    ax.set_xlabel('w')
    plt.show()

    fig, ax = plt.subplots(figsize=[8,6])
    ax.plot(dx_nc,ls='dashed',label='no cross')
    ax.plot(dx_conv,ls='dotted',label='no V')
    for c, w in zip(contriblist,wlist):
        ax.plot(Xb@w,label=f'cross,{c}%')
    ymin,ymax = ax.get_ylim()
    ylim = max(-ymin,ymax)
    ax.set_ylim(-ylimref,ylimref)
    ax.legend()
    ax.set_xlabel('grid')
    ax.set_ylabel('dx')
    plt.show()

    nrows = 1
    ncols = (1+len(contriblist))//nrows
    fig, axs = plt.subplots(nrows=nrows,ncols=ncols,sharey=True,constrained_layout=True)
    vlim = max(np.max(Xb),-np.min(Xb))
    mp0=axs.flatten()[0].matshow(Xb,norm=Normalize(-vlim,vlim))
    #fig.colorbar(mp0,ax=axs.flatten()[0],shrink=0.6,pad=0.01)
    axs.flatten()[0].set_title('Xb')
    for c, Xa in zip(contriblist,Xalist):
        i=contriblist.index(c)
        ax=axs.flatten()[i+1]
        mp1=ax.matshow(Xa,norm=Normalize(-vlim,vlim))
        #fig.colorbar(mp1,ax=ax,shrink=0.6,pad=0.01)
        ax.set_title(f'Xa,{c}%')
    fig.colorbar(mp1,ax=axs,shrink=0.6,pad=0.1)
    plt.show()

    fig, axs = plt.subplots(ncols=3,nrows=2,constrained_layout=True)
    mp0=axs[0,0].matshow(trans_nc)
    fig.colorbar(mp0,ax=axs[0,0],shrink=0.6,pad=0.01)
    axs[0,0].set_title('trans (no cross)')
    for c, trans in zip(contriblist,translist):
        i=contriblist.index(c)
        ax = axs.flatten()[i+1]
        mp1=ax.matshow(trans)
        fig.colorbar(mp1,ax=ax,shrink=0.6,pad=0.01)
        ax.set_title(f'trans,{c}%')
    plt.show()

```

2. regularization in state space
    $$
    \tilde{\mathbf{X}}^\mathrm{b}
    =
    \left[
        \begin{pmatrix}
        \mathbf{P}^\mathrm{b} & \mathbf{P}^\mathrm{bv} \\
        \mathbf{P}^\mathrm{vb} & \mathbf{P}^\mathrm{v}
        \end{pmatrix}
        +\mu\mathbf{I}
    \right]^{-1}
    \begin{pmatrix}
        \mathbf{X}^\mathrm{b}\\
        \mathbf{Z}^\mathrm{b}
    \end{pmatrix}
    $${#eq-reg-1}
    $$
    \tilde{\mathbf{d}}^\mathrm{v}
    =
    \left[
        \begin{pmatrix}
        \mathbf{P}^\mathrm{b} & \mathbf{P}^\mathrm{bv} \\
        \mathbf{P}^\mathrm{vb} & \mathbf{P}^\mathrm{v}
        \end{pmatrix}
        +\mu\mathbf{I}
    \right]^{-1}
    \begin{pmatrix}
    \mathbf{0}\\\mathbf{d}^\mathrm{v}
    \end{pmatrix}
    $${#eq-reg-2}

```{python}
#| output: false

    mulist = [0.0001,0.001,0.01,0.1,1.0]
    solverlist = []
    argslist = []
    zlist = []
    wlist = []
    Xalist = []
    translist = []
    for mu in mulist:
        #mu = 0.01
        envar_nestc = EnVAR_nest(state_size,nmem,obs,ix_gm,ix_lam,pt="envar_nestc",ntrunc=12,\
        crosscov=True,ortho=False,ridge=False,reg=True,mu=mu,model="l05nestm")
        solverlist.append(envar_nestc)

        dvtmp = np.hstack((np.zeros(Xb.shape[0]),dv))
        Pcpi = Pc+mu*np.eye(Pc.shape[0])
        Xb_ = la.solve(Pcpi,dxc2)
        dv_ = la.solve(Pcpi,dvtmp)
        args_prec = (Yb, dxc2, Xb_)
        trans, heinv = envar_nestc.precondition(*args_prec)
        args = (do, trans, Yb, dvtmp, dv_, Xb_, dxc2, heinv)
        minimize = Minimize(nmem, envar_nestc.calc_j, jac=envar_nestc.calc_grad_j, hess=envar_nestc.calc_hess, args=args)
        z, _ = minimize(np.zeros(nmem))
        w = trans @ z

        #args = (Xb, Yb, Zb, do, dv, Xb_, dv_)
        #w, trans = solve(*args)
        
        Xa = np.sqrt(nmem-1)*Xb@trans
        argslist.append(args)
        zlist.append(z)
        wlist.append(w)
        Xalist.append(Xa)
        translist.append(trans)
```
```{python}
    Jlist = []
    for mu, z, args, envar_nestc in zip(mulist,zlist,argslist,solverlist):
        Ji = envar_nestc.calc_j(np.zeros(nmem),*args)
        Jf = envar_nestc.calc_j(z,*args)
        #Ji = cost(np.zeros_like(w),*args)
        #Jf = cost(w,*args)
        print(f"mu={mu} initial cost={Ji:.4e}")
        print(f"mu={mu} final cost={Jf:.4e}")
        Jlist.append([Ji,Jf])
```

```{python}
#| fig-cap: Sensitivity of $J$ to $\mu$
#| label: fig-reg-cost-mu

    Jarray = np.array(Jlist)
    fig, ax = plt.subplots()
    #ax.plot(mulist,Jarray[:,0],marker='o',ms=10,lw=0.0,label='initial')
    ax.plot(mulist,Jarray[:,1],marker='s',ms=10,lw=0.0,label='final')
    ax.legend()
    ax.set_xscale('log')
    ax.set_ylabel('J')
    ax.set_xlabel(r'$\mu$')
    plt.show()

```

<!---
```{python}
#| fig-cap: solution with $\mu$=1.0
#| fig-subcap:
#|   - $\tilde{X}^b$
#|   - $\tilde{d}^b$
#| label: fig-reg
#| layout: [[2,3],[1]]

    fig, ax = plt.subplots()
    mp=ax.matshow(Xb_)
    fig.colorbar(mp,ax=ax,pad=0.01,shrink=0.6)
    ax.set_aspect(0.5)
    plt.show()

    fig, ax = plt.subplots()
    ax.plot(dv_,np.arange(dv_.size))
    ax.set_xlabel(r'$\tilde{d}^v$')
    ax.vlines([0],0,1,colors='gray',transform=ax.get_xaxis_transform())
    plt.show()
```
--->

```{python}
#| fig-cap: solution for $J$
#| fig-subcap:
#|   - $\mathbf{w}$
#|   - $\delta\mathbf{x}$
#|   - Xb, Xa
#|   - $[\nabla^2 J]^{-1/2}$
#| label: fig-reg-cost
#| layout: [[1,2],[1]]
    
    fig, ax = plt.subplots(figsize=[4,6])
    ax.plot(w_nc,np.arange(1,w_nc.size+1),ls='dashed',label='no cross')
    ax.plot(w_conv,np.arange(1,w_conv.size+1),ls='dotted',label='no V')
    for mu, w in zip(mulist,wlist):
        ax.plot(w,np.arange(1,w.size+1),label=r'$\mu$='+f'{mu}')
    xmin,xmax = ax.get_xlim()
    xlim = max(-xmin,xmax)
    ax.set_xlim(-xlim,xlim)
    ax.legend()
    ax.set_ylabel('member')
    ax.set_xlabel('w')
    plt.show()

    fig, ax = plt.subplots(figsize=[8,6])
    ax.plot(dx_nc,ls='dashed',label='no cross')
    ax.plot(dx_conv,ls='dotted',label='no V')
    for mu, w in zip(mulist,wlist):
        ax.plot(Xb@w,label=r'$\mu$='+f'{mu}')
    ymin,ymax = ax.get_ylim()
    ylim = max(-ymin,ymax)
    ax.set_ylim(-ylimref,ylimref)
    ax.legend()
    ax.set_xlabel('grid')
    ax.set_ylabel('dx')
    plt.show()

    nrows = 1
    ncols = (1+len(mulist))//nrows
    fig, axs = plt.subplots(nrows=nrows,ncols=ncols,sharey=True,constrained_layout=True)
    vlim = max(np.max(Xb),-np.min(Xb))
    mp0=axs.flatten()[0].matshow(Xb,norm=Normalize(-vlim,vlim))
    #fig.colorbar(mp0,ax=axs.flatten()[0],shrink=0.6,pad=0.01)
    axs.flatten()[0].set_title('Xb')
    for mu, Xa in zip(mulist,Xalist):
        i=mulist.index(mu)
        ax=axs.flatten()[i+1]
        mp1=ax.matshow(Xa,norm=Normalize(-vlim,vlim))
        #fig.colorbar(mp1,ax=ax,shrink=0.6,pad=0.01)
        ax.set_title('Xa\n'+r'$\mu$='+f'{mu}')
    fig.colorbar(mp1,ax=axs,shrink=0.6,pad=0.1)
    plt.show()

    fig, axs = plt.subplots(ncols=3,nrows=2,constrained_layout=True)
    mp0=axs[0,0].matshow(trans_nc)
    fig.colorbar(mp0,ax=axs[0,0],shrink=0.6,pad=0.01)
    axs[0,0].set_title('trans (no cross)')
    for mu, trans in zip(mulist,translist):
        i=mulist.index(mu)
        ax = axs.flatten()[i+1]
        mp1=ax.matshow(trans)
        fig.colorbar(mp1,ax=ax,shrink=0.6,pad=0.01)
        ax.set_title(r'trans, $\mu$='+f'{mu}')
    plt.show()

```

3. regularization in ensemble space (ridge regression)
    
    The inverse of error covariance is replaced by the pseudo inverse.
    $$
    J(\mathbf{w})=
    \frac{K-1}{2}
    \left\{
    \begin{pmatrix}
    \mathbf{X}^\mathrm{b} \\
    \mathbf{Z}^\mathrm{v}
    \end{pmatrix}^\dagger
    \begin{bmatrix}
    \begin{pmatrix}
    \mathbf{0}\\\mathbf{d}^\mathrm{v}
    \end{pmatrix}
    -
    \begin{pmatrix}
    \mathbf{X}^\mathrm{b}\\\mathbf{Z}^\mathrm{b}
    \end{pmatrix}
    \mathbf{w}
    \end{bmatrix}
    \right\}^\mathrm{T}
    \begin{pmatrix}
    \mathbf{X}^\mathrm{b} \\
    \mathbf{Z}^\mathrm{v}
    \end{pmatrix}^\dagger
    \begin{bmatrix}
    \begin{pmatrix}
    \mathbf{0}\\\mathbf{d}^\mathrm{v}
    \end{pmatrix}
    -
    \begin{pmatrix}
    \mathbf{X}^\mathrm{b}\\\mathbf{Z}^\mathrm{b}
    \end{pmatrix}
    \mathbf{w}
    \end{bmatrix}
    +J_\mathrm{o}(\mathbf{w})
    \underline{+J_\mathrm{r}(\mathbf{w})}
    $${#eq-ridge-cost}

```{=tex}
\begin{align*}
    \nabla_\mathbf{w}J=
    &\begin{bmatrix}
    (K-1)\left\{
    \begin{pmatrix}
    \mathbf{X}^\mathrm{b} \\
    \mathbf{Z}^\mathrm{v}
    \end{pmatrix}^\dagger
    \begin{pmatrix}
    \mathbf{X}^\mathrm{b}\\\mathbf{Z}^\mathrm{b}
    \end{pmatrix}
    \right\}^\mathrm{T}
    \begin{pmatrix}
    \mathbf{X}^\mathrm{b} \\
    \mathbf{Z}^\mathrm{v}
    \end{pmatrix}^\dagger
    \begin{pmatrix}
    \mathbf{X}^\mathrm{b}\\\mathbf{Z}^\mathrm{b}
    \end{pmatrix}
    +(\mathbf{Y}^\mathrm{b})^\mathrm{T}\mathbf{R}^{-1}\mathbf{Y}^\mathrm{b}
    \underline{+\nabla^2 J_\mathrm{r}}
    \end{bmatrix}
    \mathbf{w} \\
    &-
    (K-1)\left\{
    \begin{pmatrix}
    \mathbf{X}^\mathrm{b} \\
    \mathbf{Z}^\mathrm{v}
    \end{pmatrix}^\dagger
    \begin{pmatrix}
    \mathbf{X}^\mathrm{b}\\\mathbf{Z}^\mathrm{b}
    \end{pmatrix}
    \right\}^\mathrm{T}
    \begin{pmatrix}
    \mathbf{X}^\mathrm{b} \\
    \mathbf{Z}^\mathrm{v}
    \end{pmatrix}^\dagger
    \begin{pmatrix}
    \mathbf{0}\\\mathbf{d}^\mathrm{v}
    \end{pmatrix}
    -(\mathbf{Y}^\mathrm{b})^\mathrm{T}\mathbf{R}^{-1}\mathbf{d}^\mathrm{o}
\end{align*}
```

where $J_\mathrm{r}$ is a quadratic function of $\mathbf{w}$.

i) $L_2$ norm for ensemble weights
$$
    J_\mathrm{r}=\frac{\gamma}{2}\|\mathbf{w}\|^2_2
$${#eq-ridge}

```{python}
#| output: false

        galist = [0.0001,0.001,0.01,0.1,1.0]
        solverlist = []
        argslist = []
        zlist = []
        wlist = []
        Xalist = []
        translist = []
        for ga in galist:
            envar_nestc = EnVAR_nest(state_size,nmem,obs,ix_gm,ix_lam,pt="envar_nestc",ntrunc=12,\
            crosscov=True,ortho=False,reg=False,ridge=True,mu=ga,model="l05nestm")
            solverlist.append(envar_nestc)

            qmat = vsqrtinv @ dxc2
            dvtmp = vsqrtinv @ np.hstack((np.zeros(Xb.shape[0]),dv))
            args_prec = (Yb,qmat)
            trans, heinv = envar_nestc.precondition(*args_prec)
            args = (do, trans, Yb, dvtmp, qmat, heinv)
            minimize = Minimize(nmem, envar_nestc.calc_j, jac=envar_nestc.calc_grad_j, hess=envar_nestc.calc_hess, args=args)
            z, _ = minimize(np.zeros(nmem))
            w = trans @ z

            Xa = np.sqrt(nmem-1)*Xb@trans
            argslist.append(args)
            zlist.append(z)
            wlist.append(w)
            Xalist.append(Xa)
            translist.append(trans)
```
```{python}
        Jlist = []
        for ga, z, args, envar_nestc in zip(galist,zlist,argslist,solverlist):
            Ji = envar_nestc.calc_j(np.zeros(nmem),*args)
            Jf = envar_nestc.calc_j(z,*args)
            #Ji = cost(np.zeros_like(w),*args)
            #Jf = cost(w,*args)
            print(f"gamma={ga} initial cost={Ji:.4e}")
            print(f"gamma={ga} final cost={Jf:.4e}")
            Jlist.append([Ji,Jf])
```

```{python}
#| fig-cap: Sensitivity of $J$ to $\gamma$
#| label: fig-ridge-cost-gamma

        Jarray = np.array(Jlist)
        fig, ax = plt.subplots()
        #ax.plot(galist,Jarray[:,0],marker='o',ms=10,lw=0.0,label='initial')
        ax.plot(galist,Jarray[:,1],marker='s',ms=10,lw=0.0,label='final')
        ax.legend()
        ax.set_xscale('log')
        ax.set_ylabel('J')
        ax.set_xlabel(r'$\gamma$')
        plt.show()

```

```{python}
#| fig-cap: solution for $J$
#| fig-subcap:
#|   - $\mathbf{w}$
#|   - $\delta\mathbf{x}$
#|   - Xb, Xa
#|   - $[\nabla^2 J]^{-1/2}$
#| label: fig-ridge-cost
#| layout: [[1,2],[1]]
        
        fig, ax = plt.subplots(figsize=[4,6])
        ax.plot(w_nc,np.arange(1,w_nc.size+1),ls='dashed',label='no cross')
        ax.plot(w_conv,np.arange(1,w_conv.size+1),ls='dotted',label='no V')
        for ga, w in zip(galist,wlist):
            ax.plot(w,np.arange(1,w.size+1),label=r'$\gamma$='+f'{ga}')
        xmin,xmax = ax.get_xlim()
        xlim = max(-xmin,xmax)
        ax.set_xlim(-xlim,xlim)
        ax.legend()
        ax.set_ylabel('member')
        ax.set_xlabel('w')
        plt.show()

        fig, ax = plt.subplots(figsize=[8,6])
        ax.plot(dx_nc,ls='dashed',label='no cross')
        ax.plot(dx_conv,ls='dotted',label='no V')
        for ga, w in zip(galist,wlist):
            ax.plot(Xb@w,label=r'$\gamma$='+f'{ga}')
        ymin,ymax = ax.get_ylim()
        ylim = max(-ymin,ymax)
        ax.set_ylim(-ylimref,ylimref)
        ax.legend()
        ax.set_xlabel('grid')
        ax.set_ylabel('dx')
        plt.show()

        nrows = 1
        ncols = (1+len(galist))//nrows
        fig, axs = plt.subplots(nrows=nrows,ncols=ncols,sharey=True,constrained_layout=True)
        vlim = max(np.max(Xb),-np.min(Xb))
        mp0=axs.flatten()[0].matshow(Xb,norm=Normalize(-vlim,vlim))
        #fig.colorbar(mp0,ax=axs.flatten()[0],shrink=0.6,pad=0.01)
        axs.flatten()[0].set_title('Xb')
        for ga, Xa in zip(galist,Xalist):
            i=galist.index(ga)
            mp1=axs.flatten()[i+1].matshow(Xa,norm=Normalize(-vlim,vlim))
            #fig.colorbar(mp1,ax=axs[i+1],shrink=0.6,pad=0.01)
            axs.flatten()[i+1].set_title('Xa\n'+r'$\gamma$='+f'{ga}')
        fig.colorbar(mp1,ax=axs,shrink=0.6,pad=0.1)
        plt.show()

        fig, axs = plt.subplots(ncols=3,nrows=2,constrained_layout=True)
        mp0=axs[0,0].matshow(trans_nc)
        fig.colorbar(mp0,ax=axs[0,0],shrink=0.6,pad=0.01)
        axs[0,0].set_title('trans (no cross)')
        for ga, trans in zip(galist,translist):
            i=galist.index(ga)
            ax = axs.flatten()[i+1]
            mp1=ax.matshow(trans)
            fig.colorbar(mp1,ax=ax,shrink=0.6,pad=0.01)
            ax.set_title(r'trans, $\gamma$='+f'{ga}')
        plt.show()

```


ii) $L_2$ norm for increments
$$
    J_\mathrm{r}=\frac{\gamma}{2}\|\mathbf{X}^\mathrm{b}\mathbf{w}\|^2_2
$${#eq-ridge-dx}

```{python}
#| output: false

        galist = [0.001,0.01,0.1,1.0,10.0]
        solverlist = []
        argslist = []
        zlist = []
        wlist = []
        Xalist = []
        translist = []
        for ga in galist:
            envar_nestc = EnVAR_nest(state_size,nmem,obs,ix_gm,ix_lam,pt="envar_nestc",ntrunc=12,\
            crosscov=True,ortho=False,reg=False,ridge=False,ridge_dx=True,mu=ga,model="l05nestm")
            solverlist.append(envar_nestc)

            qmat = vsqrtinv @ dxc2
            dvtmp = vsqrtinv @ np.hstack((np.zeros(Xb.shape[0]),dv))
            args_prec = (Yb,qmat,Xb)
            trans, heinv = envar_nestc.precondition(*args_prec)
            args = (do, trans, Yb, dvtmp, qmat, Xb, heinv)
            minimize = Minimize(nmem, envar_nestc.calc_j, jac=envar_nestc.calc_grad_j, hess=envar_nestc.calc_hess, args=args)
            z, _ = minimize(np.zeros(nmem))
            w = trans @ z

            Xa = np.sqrt(nmem-1)*Xb@trans
            argslist.append(args)
            zlist.append(z)
            wlist.append(w)
            Xalist.append(Xa)
            translist.append(trans)
```
```{python}
        Jlist = []
        for ga, z, args, envar_nestc in zip(galist,zlist,argslist,solverlist):
            Ji = envar_nestc.calc_j(np.zeros(nmem),*args)
            Jf = envar_nestc.calc_j(z,*args)
            #Ji = cost(np.zeros_like(w),*args)
            #Jf = cost(w,*args)
            print(f"gamma={ga} initial cost={Ji:.4e}")
            print(f"gamma={ga} final cost={Jf:.4e}")
            Jlist.append([Ji,Jf])
```

```{python}
#| fig-cap: Sensitivity of $J$ to $\gamma$
#| label: fig-ridge-dx-cost-gamma

        Jarray = np.array(Jlist)
        fig, ax = plt.subplots()
        #ax.plot(galist,Jarray[:,0],marker='o',ms=10,lw=0.0,label='initial')
        ax.plot(galist,Jarray[:,1],marker='s',ms=10,lw=0.0,label='final')
        ax.legend()
        ax.set_xscale('log')
        ax.set_ylabel('J')
        ax.set_xlabel(r'$\gamma$')
        plt.show()

```

```{python}
#| fig-cap: solution for $J$
#| fig-subcap:
#|   - $\mathbf{w}$
#|   - $\delta\mathbf{x}$
#|   - Xb, Xa
#|   - $[\nabla^2 J]^{-1/2}$
#| label: fig-ridge-dx-cost
#| layout: [[1,2],[1]]
        
        fig, ax = plt.subplots(figsize=[4,6])
        ax.plot(w_nc,np.arange(1,w_nc.size+1),ls='dashed',label='no cross')
        ax.plot(w_conv,np.arange(1,w_conv.size+1),ls='dotted',label='no V')
        for ga, w in zip(galist,wlist):
            ax.plot(w,np.arange(1,w.size+1),label=r'$\gamma$='+f'{ga}')
        xmin,xmax = ax.get_xlim()
        xlim = max(-xmin,xmax)
        ax.set_xlim(-xlim,xlim)
        ax.legend()
        ax.set_ylabel('member')
        ax.set_xlabel('w')
        plt.show()

        fig, ax = plt.subplots(figsize=[8,6])
        ax.plot(dx_nc,ls='dashed',label='no cross')
        ax.plot(dx_conv,ls='dotted',label='no V')
        for ga, w in zip(galist,wlist):
            ax.plot(Xb@w,label=r'$\gamma$='+f'{ga}')
        ymin,ymax = ax.get_ylim()
        ylim = max(-ymin,ymax)
        ax.set_ylim(-ylimref,ylimref)
        ax.legend()
        ax.set_xlabel('grid')
        ax.set_ylabel('dx')
        plt.show()

        nrows = 1
        ncols = (1+len(galist))//nrows
        fig, axs = plt.subplots(nrows=nrows,ncols=ncols,sharey=True,constrained_layout=True)
        vlim = max(np.max(Xb),-np.min(Xb))
        mp0=axs.flatten()[0].matshow(Xb,norm=Normalize(-vlim,vlim))
        #fig.colorbar(mp0,ax=axs.flatten()[0],shrink=0.6,pad=0.01)
        axs.flatten()[0].set_title('Xb')
        for ga, Xa in zip(galist,Xalist):
            i=galist.index(ga)
            mp1=axs.flatten()[i+1].matshow(Xa,norm=Normalize(-vlim,vlim))
            #fig.colorbar(mp1,ax=axs[i+1],shrink=0.6,pad=0.01)
            axs.flatten()[i+1].set_title('Xa\n'+r'$\gamma$='+f'{ga}')
        fig.colorbar(mp1,ax=axs,shrink=0.6,pad=0.1)
        plt.show()

        fig, axs = plt.subplots(ncols=3,nrows=2,constrained_layout=True)
        mp0=axs[0,0].matshow(trans_nc)
        fig.colorbar(mp0,ax=axs[0,0],shrink=0.6,pad=0.01)
        axs[0,0].set_title('trans (no cross)')
        for ga, trans in zip(galist,translist):
            i=galist.index(ga)
            ax = axs.flatten()[i+1]
            mp1=ax.matshow(trans)
            fig.colorbar(mp1,ax=ax,shrink=0.6,pad=0.01)
            ax.set_title(r'trans, $\gamma$='+f'{ga}')
        plt.show()

```

# Comparison in a cycled experiment (preliminary result)

```{python}
#| fig-cap: RMSE for the cycled experiment with Nested Lorenz for ignoring cross covariance, incorporating cross covariance with [@eq-psd-1;@eq-psd-2] (psd), [@eq-reg-1;@eq-reg-2] with $\mu=0.01$ (reg), and [@eq-ridge] with $\gamma=0.1$ (ridge)
#| fig-subcap:
#|   - analysis
#|   - 6-h forecast
#| label: fig-comp-rmse

datadir1 = Path(f'/Volumes/nakashita/Development/pydpac/work/{model}/envar_nestc_shrink_preGM_m80obs30')
#datadir1 = Path(f'/Volumes/FF520/nested_envar/data/{model}/envar_nestc_shrink_preGM_m80obs30')
ea_nc  = np.loadtxt(datadir1/'e_lam_linear_envar_nest.txt')
ef_nc  = np.loadtxt(datadir1/'ef_lam_linear_envar_nest.txt')
ea_psd = np.loadtxt(datadir1/'e_lam_linear_envar_nestc.txt')
ef_psd = np.loadtxt(datadir1/'ef_lam_linear_envar_nestc.txt')
datadir2 = Path(f'/Volumes/nakashita/Development/pydpac/work/{model}/envar_nestc_reg_shrink_preGM_m80obs30')
#datadir2 = Path(f'/Volumes/FF520/nested_envar/data/{model}/envar_nestc_reg0.01_shrink_preGM_m80obs30')
ea_reg = np.loadtxt(datadir2/'e_lam_linear_envar_nestc.txt')
ef_reg = np.loadtxt(datadir2/'ef_lam_linear_envar_nestc.txt')
datadir3 = Path(f'/Volumes/nakashita/Development/pydpac/work/{model}/envar_nestc_ridge_shrink_preGM_m80obs30')
#datadir3 = Path(f'/Volumes/FF520/nested_envar/data/{model}/envar_nestc_ridge0.1_shrink_preGM_m80obs30')
ea_ridge = np.loadtxt(datadir3/'e_lam_linear_envar_nestc.txt')
ef_ridge = np.loadtxt(datadir3/'ef_lam_linear_envar_nestc.txt')

t = np.arange(ea_nc.size)
days = t * 0.25
nspinup = 40
fig, ax = plt.subplots()
ax.plot(days[nspinup:],ea_nc[nspinup:],label='no cross')
ax.plot(days[nspinup:],ea_psd[nspinup:],label='psd')
ax.plot(days[nspinup:],ea_reg[nspinup:],label='reg')
ax.plot(days[nspinup:],ea_ridge[nspinup:],label='ridge')
ax.set_xlabel('days')
ax.set_xlim(10.0,days[-1])
ax.legend()
plt.show()

fig, ax = plt.subplots()
ax.plot(days[nspinup:],ef_nc[nspinup:],label='no cross')
ax.plot(days[nspinup:],ef_psd[nspinup:],label='psd')
ax.plot(days[nspinup:],ef_reg[nspinup:],label='reg')
ax.plot(days[nspinup:],ef_ridge[nspinup:],label='ridge')
ax.set_xlabel('days')
ax.set_xlim(10.0,days[-1])
ax.legend()
plt.show()

```

```{python}
#| fig-cap: Averaged error in state space for the cycled experiment with Nested Lorenz for ignoring cross covariance, incorporating cross covariance with [@eq-psd-1;@eq-psd-2] (psd), [@eq-reg-1;@eq-reg-2] (reg), and [@eq-ridge] (ridge)
#| fig-subcap:
#|   - analysis
#|   - 6-h forecast
#| label: fig-comp-xdmean

xda_nc  = np.loadtxt(datadir1/'xdmean_lam_linear_envar_nest.txt')
xdf_nc  = np.loadtxt(datadir1/'xdfmean_lam_linear_envar_nest.txt')
xda_psd = np.loadtxt(datadir1/'xdmean_lam_linear_envar_nestc.txt')
xdf_psd = np.loadtxt(datadir1/'xdfmean_lam_linear_envar_nestc.txt')
xda_reg = np.loadtxt(datadir2/'xdmean_lam_linear_envar_nestc.txt')
xdf_reg = np.loadtxt(datadir2/'xdfmean_lam_linear_envar_nestc.txt')
xda_ridge = np.loadtxt(datadir3/'xdmean_lam_linear_envar_nestc.txt')
xdf_ridge = np.loadtxt(datadir3/'xdfmean_lam_linear_envar_nestc.txt')

fig, ax = plt.subplots()
ax.plot(ix_lam,xda_nc,label='no cross')
ax.plot(ix_lam,xda_psd,label='psd')
ax.plot(ix_lam,xda_reg,label='reg')
ax.plot(ix_lam,xda_ridge,label='ridge')
ax.set_xlabel('grid')
ax.legend()
plt.show()

fig, ax = plt.subplots()
ax.plot(ix_lam,xdf_nc,label='no cross')
ax.plot(ix_lam,xdf_psd,label='psd')
ax.plot(ix_lam,xdf_reg,label='reg')
ax.plot(ix_lam,xdf_ridge,label='ridge')
ax.set_xlabel('grid')
ax.legend()
plt.show()

```

```{python}
#| fig-cap: Final cost for the cycled experiment with Nested Lorenz for ignoring cross covariance, incorporating cross covariance with [@eq-psd-1;@eq-psd-2] (psd), [@eq-reg-1;@eq-reg-2] (reg), and [@eq-ridge] (ridge)
#| label: fig-comp-cost

j_nc  = np.loadtxt(datadir1/f'{model}_lam_jh_linear_envar_nest.txt')
j_psd = np.loadtxt(datadir1/f'{model}_lam_jh_linear_envar_nestc.txt')
j_reg = np.loadtxt(datadir2/f'{model}_lam_jh_linear_envar_nestc.txt')
j_ridge = np.loadtxt(datadir3/f'{model}_lam_jh_linear_envar_nestc.txt')

cycles = np.arange(j_nc.shape[0]) + 1
fig, axs = plt.subplots(nrows=2,sharex=True)
axs[0].plot(cycles,j_nc[:,0]+j_nc[:,2],label='no cross (Jb + Jv)')
axs[0].plot(cycles,j_psd[:,0],label='psd (Jbv)')
axs[0].plot(cycles,j_reg[:,0],label='reg (Jbv)')
axs[0].plot(cycles,j_ridge[:,0],label='ridge (Jbv)')
axs[0].set_ylabel('background')
axs[1].plot(cycles,j_nc[:,1],label='no cross')
axs[1].plot(cycles,j_psd[:,1],label='psd')
axs[1].plot(cycles,j_reg[:,1],label='reg')
axs[1].plot(cycles,j_ridge[:,1],label='ridge')
axs[1].set_ylabel('observation')
axs[1].set_xlabel('grid')
axs[0].legend()
plt.show()

```
